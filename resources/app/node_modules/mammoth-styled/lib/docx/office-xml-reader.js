'use strict';

const _ = require('underscore');

const promises = require('../promises');
const xml = require('../xml');


exports.read = read;
exports.readXmlFromZipFile = readXmlFromZipFile;

const xmlNamespaceMap = {
  'http://schemas.openxmlformats.org/wordprocessingml/2006/main': 'w',
  'http://schemas.openxmlformats.org/officeDocument/2006/relationships': 'r',
  'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing': 'wp',
  'http://schemas.openxmlformats.org/drawingml/2006/main': 'a',
  'http://schemas.openxmlformats.org/drawingml/2006/picture': 'pic',
  'http://schemas.openxmlformats.org/package/2006/content-types': 'content-types',
  'urn:schemas-microsoft-com:vml': 'v',
  'http://schemas.openxmlformats.org/markup-compatibility/2006': 'mc',
  'urn:schemas-microsoft-com:office:word': 'office-word',
};


async function read(xmlString) {
  const document = await xml.readString(xmlString, xmlNamespaceMap);
  return collapseAlternateContent(document)[0];
}


function readXmlFromZipFile(docxFile, path) {
  if (docxFile.exists(path)) {
    return docxFile.read(path, 'utf-8')
      .then(stripUtf8Bom)
      .then(read);
  }
  return promises.resolve(null);
}


function stripUtf8Bom(xmlString) {
  return xmlString.replace(/^\uFEFF/g, '');
}


function collapseAlternateContent(node) {
  if (node.type === 'element') {
    if (node.name === 'mc:AlternateContent') {
      return node.firstOrEmpty('mc:Fallback').children;
    }
    node.children = _.flatten(node.children.map(collapseAlternateContent, true));
    return [ node ];
  }
  return [ node ];
}
